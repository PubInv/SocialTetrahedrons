diff --git a/3Dplayground/js/main.js b/3Dplayground/js/main.js
index 61a91b6..cd7a7be 100644
--- a/3Dplayground/js/main.js
+++ b/3Dplayground/js/main.js
@@ -154,6 +154,7 @@ function load_NTetHelix(am, helix, tets, pvec, hparams) {
     return load_NTetHelixAux(am, helix, tets, pvec, coords);
 }
 
+
 function add_vertex(am, d, i, params) {
     var colors = [d3.color("DarkRed"), d3.color("DarkOrange"), d3.color("Blue")];
     var darkgreen = d3.color("#008000");
@@ -173,6 +174,10 @@ function add_vertex(am, d, i, params) {
                 case 0: th = [0, 0, 0, i]; c = [base.ec[0], base.ec[0], base.ec[0], base.vc[i]]; break;
                 case 1: th = [0, 0, 0, i]; c = [base.ec[0], base.ec[0], base.ec[0], base.vc[i]]; break;
                 case 2: th = [1, 0, 0, i]; c = [base.ec[1], base.ec[0], base.ec[0], base.vc[i]]; break;
+                
+                // case 0: th = [0, 0, 0, i]; c = [0, 0, 0, base.vc[i]]; break;
+                // case 1: th = [0, 0, 0, i]; c = [base.ec[0], 0, 0, base.vc[i]]; break;
+                // case 2: th = [1, 0, 0, i]; c = [base.ec[1], base.ec[2], 0, base.vc[i]]; break;
             }
             vertices.push(v);
             indices.push(th);
@@ -197,7 +202,7 @@ function add_vertex(am, d, i, params) {
             indices.push(th);
             c = get_colors(i, vertices, indices);
         }
-        if (params.wireframe == true) {
+    if (params.wireframe == true) {
         //        v = v.add(pvec);                
         var pos = new THREE.Vector3();
         pos.set(v.x, v.y, v.z);
@@ -279,10 +284,10 @@ function add_vertex(am, d, i, params) {
         }
         params.prev = th;
 }
-
 function cto3(c) {
      return new THREE.Color(c.hex());
 }
+
 function get_random_int(max) {
     return Math.floor(Math.random() * Math.floor(max));
 }
@@ -313,7 +318,7 @@ function get_colors(n, v, i) {
 var cs = [];
 cs[0] = new THREE.Vector3(0, 0, 0);
 cs[1] = new THREE.Vector3(1, 0, 0);
-cs[2] = new THREE.Vector3(.5, 0, - Math.sqrt(3) / 2);
+cs[2] = new THREE.Vector3(.5, Math.sqrt(3) / 2, 0);
 
 // v [a, b, c], vc[a, b, c], ec[ab, bc, ac]
 function get_base(init_pos) {
@@ -1193,17 +1198,23 @@ function clearAm() {
     am.helix_params = [];
 }
 
-function initialParameters(init_pos) { 
+function initialParameters(init_pos,wf,bc) { 
     var params = { vertices: [], indices: [], prev: [], helix: {helix_joints: [], helix_members: [],
                                                                },
                  init_pos: init_pos};
-    return params;
-}
-
-function generator_init(params) {
-        for (var i = 0; i < 3; i++) {
+    for (var i = 0; i < 3; i++) {
         add_vertex(am, 0, i, params);
     }
+    if (wf === undefined)
+        wf = true;
+    if (bc === undefined)
+        bc = true;
+    wf = false;
+    bc = false;
+   params.wireframe = wf;
+   params.blendcolor = bc;
+    
+    return params;
 }
 
 function drawTetrahedron(dir, i, other_params) {
@@ -1263,6 +1274,7 @@ function drawTetrahedron(dir, i, other_params) {
         document.getElementById("circle-button").addEventListener("click", function(){ followParametricCurve(parametricCircle, false); });
         document.getElementById("sine-button").addEventListener("click", function(){ followParametricCurve(parametricSineWave, true); });
         document.getElementById("spiral-button").addEventListener("click", function(){ followParametricCurve(parametricGoldenSpiral, true); });
+        document.getElementById("helix-button").addEventListener("click", function(){ followParametricCurve(parametricHelix, true); });
 
         
         // Fill the generators selector
@@ -1302,7 +1314,14 @@ function drawTetrahedron(dir, i, other_params) {
     }
     
     // EVENT HANDLERS
-    
+
+    function generator_init(params) {
+        for (var i = 0; i < 3; i++) {
+            add_vertex(am, 0, i, params);            
+        }
+        return params;
+    }
+
     function onExecute() {
         executeButton.disabled = true;
         generatorFn = compileGenerator(generatorText.value);
@@ -1311,9 +1330,9 @@ function drawTetrahedron(dir, i, other_params) {
             return;
         }
         clearAm();
-        var other_params = initialParameters(new THREE.Vector3(0,0,0));
-        other_params.wireframe = document.getElementById('wireframe').checked;
-        other_params.blendcolor = document.getElementById('blendcolor').checked;
+        var wf = document.getElementById('wireframe').checked;
+        var bc = document.getElementById('blendcolor').checked;
+        var other_params = initialParameters(new THREE.Vector3(0,0,0),wf,bc);
         generator_init(other_params);
         setTimeout(step, INTERVAL, generatorFn, 0, other_params);
     }
@@ -1461,7 +1480,8 @@ function drawTetrahedron(dir, i, other_params) {
     // return value if very weird here, since we have cases.
     function nextParametricTet(lpt, tc,params) {
         if (pointIsInsideTet(lpt, tc,params)) { return "INSIDECURRENT"; }
-
+        var debug = false;
+        if (debug) addDebugSphere(am,lpt,"white");
         var prev = params.prev;
         var vs = [];
         vs[0] = params.vertices[prev[0]];
@@ -1482,21 +1502,26 @@ function drawTetrahedron(dir, i, other_params) {
             valid);
         console.assert(valid.v);
 
-        addDebugSphere(am,v0,"green");
+        if (debug) addDebugSphere(am,v0,"green");
         
-        if (pointIsInsideTetPnts(lpt,v0,vs[1],vs[2],vs[3]))
+        if (pointIsInsideTetPnts(lpt,v0,vs[1],vs[2],vs[3])) {
+            console.log("return",lpt,0);
             return 0;
-        
+        }
+
+        // I don't know why I need this chirality change, but I do.
         var v1 = find_fourth_point_given_three_points_and_three_distances(
             CHIRALITY_CCW,
-            vs[0], vs[2], vs[3],            
+             vs[2],vs[0], vs[3],            
             te, te, te,
             valid);
         console.assert(valid.v);
-        addDebugSphere(am,v1,"blue");        
+        if (debug) addDebugSphere(am,v1,"blue");        
         
-        if (pointIsInsideTetPnts(lpt,vs[0],v1,vs[2],vs[3]))
+        if (pointIsInsideTetPnts(lpt,vs[0],v1,vs[2],vs[3])) {
+            console.log("return",lpt,1);            
             return 1;
+        }
         
         var v2 = find_fourth_point_given_three_points_and_three_distances(
             CHIRALITY_CCW,
@@ -1505,10 +1530,12 @@ function drawTetrahedron(dir, i, other_params) {
             valid);
         console.assert(valid.v);
         
-        if (pointIsInsideTetPnts(lpt,vs[0],vs[1],v2,vs[3]))
+        if (pointIsInsideTetPnts(lpt,vs[0],vs[1],v2,vs[3])) {
+            console.log("return",lpt,2);                        
             return 2;
+        }
 
-        addDebugSphere(am,v2,"red");                
+        if (debug) addDebugSphere(am,v2,"red");                
 
         var v3 = find_fourth_point_given_three_points_and_three_distances(
             CHIRALITY_CCW,
@@ -1517,13 +1544,13 @@ function drawTetrahedron(dir, i, other_params) {
             valid);
         console.assert(valid.v);
 
-        addDebugSphere(am,v3,"white");
+        addDebugSphere(am,v3,"gray");
         
         if (pointIsInsideTetPnts(lpt,vs[0],vs[1],vs[2],v3)) {
             console.log("CURVE WENT BACKWARD!");
             return 3;
         }
-        
+        console.log("NORREACH",lpt);
         // otherwise we can't reach it in one...
         return "NOREACH";
         
@@ -1577,8 +1604,8 @@ function drawTetrahedron(dir, i, other_params) {
         console.assert(0 == nt );        
         // var B = new THREE.Vector3(0,0,0);
         // console.assert(nextParametricTet(B, 3 ,params) );                 var C = new THREE.Vector3(0,0,0);
-        // console.assert(nextParametricTet(C, 3 ,params) );         
-        
+        // console.assert(nextParametricTet(C, 3 ,params) );
+        clearAm();        
     }
     test_nextParametricTet();
 
@@ -1604,6 +1631,26 @@ function drawTetrahedron(dir, i, other_params) {
         return new THREE.Vector3(x,y,0);
 //        return [x,y];
     }
+    function parametricHelixPure(i) {
+        if (i>=720) { return false; }
+        var j = i * 10;
+        var theta = j/360*2*Math.PI;
+        var radius = 2;
+        var x = radius * Math.cos(theta);
+        var y = radius * Math.sin(theta);
+        var z = j/320;
+        return new THREE.Vector3(x,y,z);
+    }
+    function parametricHelix(i) {
+        if (i>=360) { return false; }
+        var j = i * 10;
+        var theta = j/360*2*Math.PI;
+        var radius = 1 + (i/120);
+        var x = radius * Math.cos(theta);
+        var y = radius * Math.sin(theta);
+        var z = j/319;
+        return new THREE.Vector3(x,y,z);
+    }
 
     // Takes integer i parameter 0,1,2,..., returns [x,y] curve coordinate.
     function parametricGoldenSpiral(i) {
@@ -1752,9 +1799,11 @@ function drawTetrahedron(dir, i, other_params) {
         // }
 
         
-//        tc = tetNext;
+        //        tc = tetNext;
+
+        console.log("calling ADDVERTEX",tetNext,tci+1);
 
-        add_vertex(am, tetNext, tci, params);
+        add_vertex(am, tetNext, tci+1, params);
         
         tci++;
         
