<!--
Copyright (C) 2019 by
  Robert L. Read <read.robert@gmail.com>
  
  This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as
    published by the Free Software Foundation, either version 3 of the
    License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
-->
<!doctype html>
<html lang="en">
  <head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <link rel="stylesheet" href="https://code.jquery.com/ui/1.12.1/themes/base/jquery-ui.css">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/bootstrap-slider/10.6.0/bootstrap-slider.js"></script>

    <script src="./js/three.js"></script>
    
    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">

  <script src="https://code.jquery.com/jquery-1.12.4.js"></script>
  <script src="https://code.jquery.com/ui/1.12.1/jquery-ui.js"></script>

  <script src="https://cdn.jsdelivr.net/npm/interactjs@1.3/dist/interact.min.js"></script>

  <link rel="stylesheet" href="./css/bootstrap-slider.css"></script>
    <style>

#ex1Slider .slider-selection {
	background: #BABABA;
}
      /* Tabs*/
section {
    padding: 60px 0;
}

section .section-title {
    text-align: center;
    color: #007b5e;
    margin-bottom: 50px;
    text-transform: uppercase;
}
#tabs{
	background: #007b5e;
    color: #eee;
}
#tabs h6.section-title{
    color: #eee;
}

#tabs .nav-tabs .nav-item.show .nav-link, .nav-tabs .nav-link.active {
    color: #f3f3f3;
    background-color: transparent;
    border-color: transparent transparent #f3f3f3;
    border-bottom: 4px solid !important;
    font-size: 20px;
    font-weight: bold;
}
#tabs .nav-tabs .nav-link {
    border: 1px solid transparent;
    border-top-left-radius: .25rem;
    border-top-right-radius: .25rem;
    color: #eee;
    font-size: 20px;
}

canvas {
    border: 1px solid black;
    width: 100%;
    height: 400px;
}

    </style>

    <style>
      body { font-family: Helvetica, Arial, sans-serif; }

.dropzone-wrapper {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
}

.dropzone {
    overflow: hidden;
    margin: .5em;
    padding: 1em;
    color: #666;
    text-align: center;
    background: #ccc;
    line-height: 8em;
    border: 4px dashed transparent;
    transition: background .15s linear, border-color .15s linear;
}

.dropzone.-drop-possible { border-color: #666; }

.dropzone.-drop-over {
    background: #666;
    color: #fff;
}

.draggable {
    position: relative;
    z-index: 10;
    width: 200px;
    margin: .25em;
    padding: 1em 2em;
    background-color: #29e;
    color: #fff;
    text-align: center;

    -ms-touch-action: none;
        touch-action: none;
}

.draggable.-drop-possible { background-color: #42bd41; }

      </style>

<body>
<br>
<div class="container">

  	<h6 class="section-title h1">Tabs</h6>
		<div class="row">
    <div class="col">
				<nav>
					<div class="nav nav-tabs nav-fill" id="nav-tab" role="tablist">
						<a class="nav-item nav-link active" id="nav-create-tab" data-toggle="tab" href="#nav-create" role="tab" aria-controls="nav-create" aria-selected="true">Create Social Tetrahedrons</a>
						<a class="nav-item nav-link" id="nav-show-tab" data-toggle="tab" href="#nav-social" role="tab" aria-controls="nav-show" aria-selected="false">Show Social Tetrahedrons</a>
					</div>
				</nav>
				<div class="tab-content py-3 px-3 px-sm-0" id="nav-tabContent">
    <div class="tab-pane fade show active" id="nav-create" role="tabpanel" aria-labelledby="nav-create-tab">

 <div class="row">
      <div class="col-2 col-sm-1">
    <input id="ex4" type="text" data-slider-min="-5" data-slider-max="20" data-slider-step="1" data-slider-value="-3" data-slider-orientation="vertical"/>    
      </div>
    <div class="col-4 col-sm-11">
    
    <div id="create-canvas">
<!-- <div class="dropzone-wrapper"> -->
  <svg id="create_svg"  class="dropzone js-drop" height="500" width="500" viewbox="-250 -250 500 500"> 
</svg>
<!-- </div> -->
    </div>
      </div>
    </div>
    
					</div>
					<div class="tab-pane fade" id="nav-social" role="tabpanel" aria-labelledby="nav-show-tab">
    <div id="social-canvas">
    <canvas id='socialcanvasid'>
    <\canvas>
    </div>
					</div>
    </div>


    
			</div>
                        
			<div class="col">
				<nav>
					<div class="nav nav-tabs nav-fill" id="nav-tab" role="tablist">
						<a class="nav-item nav-link active" id="nav-projects-tab" data-toggle="tab" href="#nav-projects" role="tab" aria-controls="nav-projects" aria-selected="true">Projects</a>
						<a class="nav-item nav-link" id="nav-persons-tab" data-toggle="tab" href="#nav-persons" role="tab" aria-controls="nav-persons" aria-selected="false">Persons</a>
						<a class="nav-item nav-link" id="nav-places-tab" data-toggle="tab" href="#nav-places" role="tab" aria-controls="nav-places" aria-selected="false">Places</a>
						<a class="nav-item nav-link" id="nav-tools-tab" data-toggle="tab" href="#nav-tools" role="tab" aria-controls="nav-tools" aria-selected="false">Tools</a>
					</div>
				</nav>
				<div class="tab-content py-3 px-3 px-sm-0" id="nav-tabContent">
    <div class="tab-pane fade show active" id="nav-projects" role="tabpanel" aria-labelledby="nav-projects-tab">

<ul class="list-group" id="nav-projects-list">
  <li class="list-group-item active">Cras justo odio</li>
</ul>
					</div>
					<div class="tab-pane fade" id="nav-persons" role="tabpanel" aria-labelledby="nav-persons-tab">
<ul class="list-group" id="nav-persons-list">
  <li class="list-group-item active">Cras justo odio</li>
</ul>

					</div>
					<div class="tab-pane fade" id="nav-places" role="tabpanel" aria-labelledby="nav-places-tab">
<ul class="list-group" id="nav-places-list">
  <li class="list-group-item active">Cras justo odio</li>
</ul>
								</div>
					<div class="tab-pane fade" id="nav-tools" role="tabpanel" aria-labelledby="nav-tools-tab">
<ul class="list-group" id="nav-tools-list">
  <li class="list-group-item active">Cras justo odio</li>
</ul>
					</div>
				</div>
			</div>
		</div>
	</div>
</div>

    <label for="mind">Mind </label>
    <span type="text" id="mind"></span><br>
    
    <label for="body">Body: </label>
    <span type="text" id="body"></span><br>
    
    <label for="spirit">Spirit: </label>
    <span type="text" id="spirit"></span><br><br>
    
<!-- 
<div id="drag1" class="draggable js-drag">Drag me…</div>
<div id="drag2" class="draggable js-drag">Drag me…</div>
<div id="drag3" class="draggable js-drag">Drag me…</div>
    <div id="drag4" class="draggable js-drag">Drag me…</div>
    -->


   <!-- Optional JavaScript -->
    <!-- jQuery first, then Popper.js, then Bootstrap JS -->
    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>

    <script src="./js/bootstrap-slider.js"></script>
    
    <script>

// TODOS:
// Make the drag and drop be more targeted.
// Make the data persist.
// Make the 4th dimesion work
// Separate out the MBS triangle into literate project
// 

// Trying now to create a basic object model in JavaScript which can later be tied to
// to a datamodel

// OBJECTS
// Effectively thise arrays represent an in-memory databes before we hook up Redis or Firebase or something.

var PROJECTS = [];
var PERSONS = [];
var PLACES = [];
var TOOLS = [];

// Now some constructors to give these things some shapes

function Project(name,source,url) {
    this.name = name;
    this.source = source;
    this.url = url;
}

function Person(name,email) {
    this.name = name;
    this.email = email;
}

function Place(name,lat,lon) {
    this.lat = lat;
    this.lon = lon;
    this.name = name;
}

function Tool(name,level) {
    this.name = name;
    this.level = level;
}

function TetType(type,A_name,B_name,C_name,D_name) {
    this.type = type;
    this.A_Name = A_name;
    this.B_Name = B_name;
    this.C_Name = C_name;
    this.D_Name = D_name;
}

function MBSCTet() {
    TetType.call(this,"MBSC","Mind","Body","Spirit","Comfort");
}

function Tetrahedron(key,type) {
    this.key = key;
    this.type = type;
    // I'm assuming these are the four independent dimensions
    // and that the type gives the names of these dimensions
    this.A = 0;
    this.B = 0;
    this.C = 0;
    this.D = 0;
}

// Now, before I will create a function to populate a test database....
function InitProjects() {
    PROJECTS.push(new Project('Project #16: "Gluss", A Robotic Truss','Public Invention',''));
    PROJECTS.push(new Project('Project #3, Human-powered Rotary Lawn Mower','Public Invention',''));
    PROJECTS.push(new Project('Project #28: Develop toolkit for the design of easily constructable CMS joints','Public Invention',''));
    PROJECTS.push(new Project('Project #34: Ferrofluid based actuator','Public Invention',''));
    PROJECTS.push(new Project('Project #12: Magnetic Bearing for Cam-and-Following System','Public Invention',''));
    PROJECTS.push(new Project('Project #13: "Changing Slope" Continuously Variable Transmission','Public Invention',''));
    PROJECTS.push(new Project('Project #29: Continuously variable linkage with linear motor member','Public Invention',''));
    PROJECTS.push(new Project('Project #36: Motile Ferrofluid Snail','Public Invention',''));
    PROJECTS.push(new Project('Project #4: Maximum work from an Adiabatic Expansion of a Piston','Public Invention',''));
    PROJECTS.push(new Project('Project #6: "Air Treader", resistance-based flight','Public Invention',''));
    PROJECTS.push(new Project('Project #5: More Efficient Pot for Heating Water','Public Invention',''));
    PROJECTS.push(new Project('Project #8: Power-of-2 Square Gas Compression Chamber','Public Invention',''));
    PROJECTS.push(new Project('Project #11: Control Heat Engine or ICE with Cam-Follower rather than Crank Shaft','Public Invention',''));
    PROJECTS.push(new Project('Project #24: Very simple heat engine with bistable magnetic device','Public Invention',''));
    PROJECTS.push(new Project('Project #41: Rapid coliform presence detector','Public Invention',''));
    PROJECTS.push(new Project('Project #21: Interactive Model of Inputs and Outputs in Waste Treatment','Public Invention',''));
    PROJECTS.push(new Project('Project #9: Human Waste Sanitation Through Thermal DepolymerizationImmature Ideas','Public Invention',''));
    PROJECTS.push(new Project('Project #23: Pyrolysis Toilet','Public Invention',''));
    PROJECTS.push(new Project('Project #25: In-pipe fan with gas sensor for EWB','Public Invention',''));
    PROJECTS.push(new Project('Project #14: In-situ Brush Pile to Biochar Converter','Public Invention',''));
    PROJECTS.push(new Project('Project #15: Stovetop Micro-Retort For Experimentation','Public Invention',''));
    PROJECTS.push(new Project('Project #19: Single-chamber biochar producer and stove','Public Invention',''));
    PROJECTS.push(new Project('Project #40: For oil painting, a wheel for very thin lines','Public Invention',''));
    PROJECTS.push(new Project('Project #38: 3D-printable variable length snap line','Public Invention',''));
    PROJECTS.push(new Project('Project #17: Grow Wooden Objects Directly','Public Invention',''));
    PROJECTS.push(new Project('Project #37: Solar-ice','Public Invention',''));
    PROJECTS.push(new Project('Project #20: Personal Stool Analysis','Public Invention',''));
    PROJECTS.push(new Project('Project #43: Software to compute helix from repeated object stacking','Public Invention',''));
    PROJECTS.push(new Project('Project #1: "Little Free Library" mobile app','Public Invention',''));
    PROJECTS.push(new Project('Project #10, Free Transparent Public Accounting','Public Invention',''));
    PROJECTS.push(new Project('Project #22: Abstract Data Type: Conserved Quantities','Public Invention',''));
    PROJECTS.push(new Project('Project #31: Oracular Graph Paper','Public Invention',''));
    PROJECTS.push(new Project('Project #32: Computational Theory Based on Progressive Refinement of Inputs','Public Invention',''));
    PROJECTS.push(new Project('Project #30: Build a map of common irrational combinations','Public Invention',''));
    PROJECTS.push(new Project('Project #2: Lovecraft, The Programming Language','Public Invention',''));
    PROJECTS.push(new Project('Project #35: Develop new view of the expansion of e-to-the-x','Public Invention',''));
    PROJECTS.push(new Project('Project #42: Volumetric Colony Counting','Public Invention',''));
    PROJECTS.push(new Project('Project #39: Botanical Embedded Chemical Sensor','Public Invention',''));
    PROJECTS.push(new Project('Project #18: Virtual Soundscape Recorder and Wildlife Locator','Public Invention',''));
    PROJECTS.push(new Project('Project #7: Color-block-based Writing System','Public Invention',''));
    PROJECTS.push(new Project('Project #33: Use PVA to 3D print dissolvable molds for fluids','Public Invention',''));
    PROJECTS.push(new Project('Project #27: Space Propulsion via throwing and catching projectiles','Public Invention',''));
    PROJECTS.push(new Project('Project #44: Social Tetrahedrons','Public Invention',''));
    PROJECTS.push(new Project('Project #45: Segmented Helices generated by chains of Repeated Units','Public Invention',''));
}
function InitDatabase() {
    InitProjects();
    PROJECTS.push(new Project('Gluss (robotic truss))','Public Invention','https://pubinv.github.io/tetrobot/'));
    PROJECTS.push(new Project('Geotagtext','Public Invention','https://github.com/PubInv/geotagtext'));
    PERSONS.push(new Person('Robert L. Read','read.robert@gmail.com'));
    PLACES.push(new Place('Poindexter\'s Lab',30.252408, -97.774618));
    TOOLS.push(new Tool('JavaScript',4));
}

function list_item(content) {
    return '<li class="list-group-item">'+content+'</li>';
}
function list_item_draggable(content) {
    return '<li class="list-group-item draggable js-drag">'+content+'</li>';    
        // <div id="drag1" class="draggable js-drag">Drag me…</div>
        // <div id="drag2" class="draggable js-drag">Drag me…</div>
        // <div id="drag3" class="draggable js-drag">Drag me…</div>
        // <div id="drag4" class="draggable js-drag">Drag me…</div>
}
// These function convert my abstract coordinates
// to canvas coordinates.
function vph(h,y) { return (-y); }
function vpw(w,x) { return (x); }

var ADDED_TET_PROJs = [];;

function append_text(svg,x,y,text) {
    var newText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    newText.setAttributeNS(null,"x",x);      
    newText.setAttributeNS(null,"y",y);   
    var textNode = document.createTextNode(text);
    newText.appendChild(textNode);
    svg.appendChild(newText);
}

var WORLD_TRIANGLE_COORDS;
const w = 500;
const h = 500;

const TRIANGLE_WIDTH = 1;
const TRIANGLE_HEIGHT = Math.sqrt(3)/2;
const SIDE_LENGTH_PIXEL = 400;
const SIDE_LENGTH_HEIGHT = SIDE_LENGTH_PIXEL * TRIANGLE_HEIGHT;
const BASE = -(1/3) * SIDE_LENGTH_HEIGHT;

function get_world_triangle() {
     let wtc = [[-SIDE_LENGTH_PIXEL/2,BASE],
                             [SIDE_LENGTH_PIXEL/2,BASE],
               [0,BASE+SIDE_LENGTH_HEIGHT]];
    return wtc;
}

function render_create_svg() {
    var svg = $("#create_svg")[0];
    $("#create_svg").empty();
    var polygon = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
    svg.appendChild(polygon);

    let wtc = WORLD_TRIANGLE_COORDS;

    var array = [ [ vpw(w,wtc[0][0]),vph(h,wtc[0][1]) ], 
                  [ vpw(w,wtc[1][0]),vph(h,wtc[1][1]) ],
                  [ vpw(w,wtc[2][0]),vph(h,wtc[2][1]) ] ];
    
    for (value of array) {
        var point = svg.createSVGPoint();
        point.x = value[0];
        point.y = value[1];
        polygon.points.appendItem(point);
    }
    polygon.style.fill='pink';


    // These are ugly, they should really be computed from the text.
    // In fact, since this does not change, the whole thing could go into
    // HTML and css more profitably.
    append_text(svg,array[2][0]-20,array[2][1]-5,"Spirit");
    append_text(svg,array[0][0]-40,array[0][1]+20,"Mind");
    append_text(svg,array[1][0],array[1][1]+20,"Body");
    
    var circle = document.createElementNS("http://www.w3.org/2000/svg", 'circle');
    circle.setAttributeNS(null, 'cx', vpw(w,0));
    circle.setAttributeNS(null, 'cy', vph(h,0));
    circle.setAttributeNS(null, 'r', 2);
    circle.setAttributeNS(null, 'style', 'fill: blue; stroke: blue; stroke-width: 1px;' );
    svg.appendChild(circle);
    
    // var newText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    // newText.setAttributeNS(null,"x",array[2][0]);      
    // newText.setAttributeNS(null,"y",array[2][1]);   
    // var textNode = document.createTextNode("Mind");
    // newText.appendChild(textNode);
    // svg.appendChild(newText);

    ADDED_TET_PROJs.forEach( ADDED_TET_POS => {
        if (ADDED_TET_POS) {
            var polygon = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
            svg.appendChild(polygon);
            var F = 0.05;

            var array = arr = [ [ vpw(w,ADDED_TET_POS.x + F*-SIDE_LENGTH_PIXEL/2),vph(h,ADDED_TET_POS.y + F*BASE) ], 
                                [ vpw(w,ADDED_TET_POS.x + F*SIDE_LENGTH_PIXEL/2),vph(h,ADDED_TET_POS.y + F*BASE) ],
                                [ vpw(w,ADDED_TET_POS.x + 0),vph(h,ADDED_TET_POS.y + F*(BASE+SIDE_LENGTH_HEIGHT)) ] ];
            for (value of array) {
                var point = svg.createSVGPoint();
                point.x = value[0];
                point.y = value[1];
                polygon.points.appendItem(point);
            }
            //console.log("ARRAY",array);
            polygon.style.fill='blue';
            svg.appendChild(polygon);
            
        }
    });
}

function render(groupid,array,f) {
    //actually, we need an Html element to add to here,
    //but I will just do this.
    $(groupid).empty();
    array.forEach(p => {
        $(groupid).append(list_item_draggable(f(p)));
    });
}

function render_svgs() {
    render_create_svg();
}

function main() {
    InitDatabase();
    render('#nav-projects-list',PROJECTS,(p => p.name));
    render('#nav-persons-list',PERSONS,(p => p.name));
    render('#nav-places-list',PLACES,(p => p.name));
    render('#nav-tools-list',TOOLS,(p => p.name));
//    render_canvases();
    render_svgs();

    // With JQuery
$("#ex4").slider({
	reversed : true
});

}


// A $( document ).ready() block.
$( document ).ready(function() {
    console.log( "ready!" );
    main();
                            });


let transformProp;

interact.maxInteractions(Infinity);

var ORIG_CUR_POS;
var startPos;
var CUR_WIDTH;
var CUR_HEIGHT;
var CUR_FONT_SIZE;
var CUR_TEXT;

// setup draggable elements.
interact('.js-drag')
  .draggable({
      max: Infinity,
//    snap: {
//      targets: [interact.createSnapGrid({ x: 100, y: 100 })],
//      relativePoints: [{ x: 0.5, y: 0.5 }],
//    },
  })
  .on('dragstart', function (event) {
    event.interaction.x = parseInt(event.target.getAttribute('data-x'), 10) || 0;
      event.interaction.y = parseInt(event.target.getAttribute('data-y'), 10) || 0;
      console.log("X Y",event.interaction.x,event.interaction.y);
      console.log("EVENT",event);
      if (!startPos) {
          var rect = interact.getElementRect(event.target);
          console.log("RECT",rect);
          CUR_POS_X = event.clientX - rect.left;
          CUR_POS_Y = event.clientY - rect.top;
          console.log("CUR POS",CUR_POS_X,CUR_POS_Y);

          // record center point when starting the very first a drag
          startPos = {
              x: rect.left + rect.width  / 2,
              y: rect.top  + rect.height / 2
          }
        CUR_WIDTH = event.target.style.width;
        CUR_HEIGHT = event.target.style.height;
        CUR_FONT_SIZE = event.target.style.fontSize;
          CUR_TEXT = event.target.textContent;
          console.log("CUR_TEXT",CUR_TEXT);
          console.log("startPos",startPos);
      };
      console.log("START",event.target.getAttribute('data-x'),event.target.getAttribute('data-y'));
  })
    .on('dragend',function (event) {
        event.target.style.width = CUR_WIDTH;
        event.target.style.height = CUR_HEIGHT;
        event.target.style.fontSize = CUR_FONT_SIZE;
        event.target.textContent = CUR_TEXT;        
        event.target.style.left = "" + 0 + "px";
        event.target.style.top = "" + 0 + "px";
        startPos = null;
        render_svgs();
        event.interaction.x = 0;
        event.interaction.y = 0;        
        event.target.setAttribute('data-x', event.interaction.x);
    event.target.setAttribute('data-y', event.interaction.y);
  })
  .on('dragmove', function (event) {
    event.interaction.x += event.dx;
    event.interaction.y += event.dy;

    if (transformProp) {
      event.target.style[transformProp] =
        'translate(' + event.interaction.x + 'px, ' + event.interaction.y + 'px)';
    }
      else {
          var lw = -20; // this is the width of the draggable element
          var lh = -10; // this is the width of the draggable element          
      event.target.style.left = CUR_POS_X+ lw + event.interaction.x + 'px';
      event.target.style.top  = CUR_POS_Y+ lh + event.interaction.y + 'px';
    }
  })
 .on('dragleave', function (event) {
        event.draggable.snap(false);

        // when leaving a dropzone, snap to the start position
        event.draggable.snap({ anchors: [startPos] });

        // remove the drop feedback style
        event.target.classList.remove('drop-target');
        event.relatedTarget.classList.remove('can-drop');
    });

// setup drop areas.
// dropzone #1 accepts draggable #1
// setupDropzone('#create_svg', '#drag1');
// setupDropzone('#create_svg', '#drag1');
// dropzone #2 accepts draggable #1 and #2
// setupDropzone('#create_svg', '#drag1, #drag2');
// every dropzone accepts draggable #3
setupDropzone('.js-drop', '.js-drag');

// This code from here: https://stackoverflow.com/questions/14307158/how-do-you-check-for-intersection-between-a-line-segment-and-a-line-ray-emanatin
// Note this routine seems to depend on the chirality of the points; possibly it only counts an approach from one side.
function GetRayToLineSegmentIntersection(rayOrigin,rayDirection,point1,point2)
{
    var ro = new THREE.Vector2(rayOrigin.x,rayOrigin.y);
    var rd = new THREE.Vector2(rayDirection.x,rayDirection.y);
    rd.normalize();
    var p1 = new THREE.Vector2(point1.x,point1.y);
    var p2 = new THREE.Vector2(point2.x,point2.y);
    var v1 = new THREE.Vector2().subVectors(ro,p1);
    var v2 = new THREE.Vector2().subVectors(p2,p1);    

    // This is construct a perpendicular.
    var v3 = new THREE.Vector2(-rd.y,rd.x);
    var dot = v2.dot(v3);

    if (Math.abs(dot) < 0.000001)
            return null;

    var t1 = v2.cross(v1) / dot;
    
    var t2 = v1.dot(v3) /dot;    

    if (t1 >= 0.0 && (t2 >= 0.0 && t2 <= 1.0)) {
        rd.multiplyScalar(t1);
        return [ro.add(rd),t1];
    }
    return null;
}
// This is a crummy hack because the above code doesn't work when the segment points are in a particular order.
function GetRayToLineSegmentInt(rayOrigin,rayDirection,p1,p2) {
    return GetRayToLineSegmentIntersection(rayOrigin,rayDirection,p1,p2);
}
function testGetRayToLineSegmentIntersection() {
    let ro = new THREE.Vector2(0,0);
    let rd = new THREE.Vector2(1,1);
    let p1 = new THREE.Vector2(0,10);
    let p2 = new THREE.Vector2(10,0);
    var r = GetRayToLineSegmentInt(ro,rd,p1,p2)[0];
    console.assert(r.x == r.y);
    var r = GetRayToLineSegmentInt(ro,rd,p2,p1)[0];
    console.log(r);
    console.assert(r.x == r.y);

    var rd1 = new THREE.Vector2(94.1015625,-36.36328125);
    let c0 = new THREE.Vector2(WORLD_TRIANGLE_COORDS[0][0],WORLD_TRIANGLE_COORDS[0][1]);
    let c1 = new THREE.Vector2(WORLD_TRIANGLE_COORDS[1][0],WORLD_TRIANGLE_COORDS[1][1]);
    let c2 = new THREE.Vector2(WORLD_TRIANGLE_COORDS[2][0],WORLD_TRIANGLE_COORDS[2][1]);        

    var r12 = GetRayToLineSegmentInt(ro,rd1,c1,c2);
    console.assert(r12 != null);
    
}

function distance(x0,y0,x1,y1) {
    return Math.sqrt((x0 - x1)**2 + (y0 - y1)**2);
}
function Frazier2to3(obj,wtc) {
    let x = obj.x;
    let y = obj.y;
    let d0 = distance(x,y,wtc[0][0],wtc[0][1]);
    let d1 = distance(x,y,wtc[1][0],wtc[1][1]);
    let d2 = distance(x,y,wtc[2][0],wtc[2][1]);
    console.log("x,y",x,y);
    console.log(wtc[0],wtc[1],wtc[2]);
    console.log("distances",d0,d1,d2);
    let d0i = 1/d0;
    let d1i = 1/d1;
    let d2i = 1/d2;
    let d = Math.sqrt(d0i**2 + d1i**2 + d2i**2);
    let v = [d0i/d,d1i/d,d2i/d];
    let dc = Math.sqrt(v[0]**2 + v[1]**2 + v[2]**2);
    console.log("dc",dc);
    return v;
}

// This is the fundamental math behind a TriBalance Diagram.
// I will probably put this in LaTeX soon.
// A balance diagram is a way of choosing a unit vector
// of n dimensions (most usefully 3) from a n-gon.
// If n > 3, it is not possible to complete map all points.
// The fundamental math of a TriBalance diagram is to convert
// between a point on the 2-dimensional n-gon (the "representation") from
// the "balance" -- a n-dimensional vector.
// Call the function that produces the repesentation from a unit vector
// "r" and the function that produces the balance vector from the respresentation "b".
// Desiderator of these functions are:
// We want them to be inversions of each other.
// We want the center of the representation to map to a balanced vector.
// A representation at the vertex is a vector having a single 1 and the rest zeros.
// As we change the angle betwen the origin and the point in a representation toward a vertex,
// the value of that vertex should increase.
// As we move along such a line, we should not change the relative proportion of the
// other values. (this is vague).
// It should be easy to compute and explain (at least geometrically.)
// I now believe this should allow a "norm" to be passed in
// as a function. I think the L1 norm is probably better than L2
// norm for some functions, but it can be optional.
// It is essential that this function be invertible.

function L1NORM(v) {
    let r = new THREE.Vector3(0,0).manhattanDistanceTo(v);
    v.divideScalar(r);
}
function L2NORM(v) {
    v.normalize();
}
function L1LENGTH(v) {
    let r = new THREE.Vector3(0,0).manhattanDistanceTo(v);
    return r;
}
function L2LENGTH(v) {
    return v.length();
}

var L1 = [L1NORM,L1LENGTH];
var L2 = [L2NORM,L2LENGTH];

function TriBalance2to3(obj,wtc,normalize = L2NORM) {
    // First, let's set everything up in THREE.js so we can use vector math...
    let WTC = [new THREE.Vector2(wtc[0][0],wtc[0][1]),
               new THREE.Vector2(wtc[1][0],wtc[1][1]),
               new THREE.Vector2(wtc[2][0],wtc[2][1])];
    let ro = new THREE.Vector2(0,0);
    
    let p = new THREE.Vector2(obj.x,obj.y);
    // Now we want to do a linear interpolation of how far we are from an edge,
    // but also how far the projection to the edge is between the vertices.
    // We must first decide which edges the line form the orign to p intersects.
    // If it intersects two segments, then are aimed at a vertex.
    var first;
    var first_idx = -1;
    for(var i = 0; i < 3; i++) {
        var r = GetRayToLineSegmentInt(ro,p,WTC[i],WTC[(i +1) %3]);
        if (r != null) {
            first_idx = i;
            first = r;
        }
    }
    console.assert(first != null);
    if (first == null) {
        console.log("UNABLE TO FIND",obj);
    }
    // now first tells us an edge struck by the ray. We will now
    // compute the distances...
    // This is the distance to the edge...
    let total_distance_to_edge = ro.distanceTo(first[0]);
    p.clampLength(0,total_distance_to_edge);
    var p_to_edge = p.distanceTo(first[0])/ro.distanceTo(first[0]);
    let BAL = new THREE.Vector3(1,1,1);

    // Now the remainder of the contribution
    // to the unit vector should come from the two
    // points on the edge, in linear proportion.
    // These coordinates are first_idx and (first_idx+1) % 3.
    var d1 = WTC[first_idx].distanceTo(first[0]);
    var d2 = WTC[(first_idx+1)%3].distanceTo(first[0]);
    let vs = [0,0,0];
    vs[first_idx] = d2;
    vs[(first_idx+1) % 3] = d1;
    let IMB = new THREE.Vector3(vs[0],vs[1],vs[2]);

    normalize(BAL);
    BAL.multiplyScalar(p_to_edge);
    normalize(IMB);
    IMB.multiplyScalar(1-p_to_edge);
    // now construct a balanced vector proportional
    // to the length from the edge to the p towards the axis
    // so that this be a unit vector if p is the origin.
    let result = new THREE.Vector3();
    result.add(IMB);
    result.add(BAL);
    return result;
    
}

// This is an attempt to invert the above function, which is basically needed
function invertTriBalance2to3(vec,wtc,normAndLen = L2) {
    let WTC = [new THREE.Vector2(wtc[0][0],wtc[0][1]),
               new THREE.Vector2(wtc[1][0],wtc[1][1]),
               new THREE.Vector2(wtc[2][0],wtc[2][1])];
    
    // First, can we determine the blance and imbalance coefficients?
    let min = Math.min(Math.min(vec.x,vec.y),vec.z);
    let imb = new THREE.Vector3(vec.x - min, vec.y - min, vec.z - min);
    let bal = vec.clone();
    bal.sub(imb);
    // Now that we have balance, we need to compute it's length---unfortuantely,
    // This length is dependent on the norm we chose!
    let length = normAndLen[1];
    let imb_r = length(imb);
    let bal_r = length(bal);
    console.log(" L(VEC),L(BAL), L(IMB)",length(vec),bal_r,imb_r);;
    console.assert(Math.abs((bal_r+imb_r) - 1) <   1e-5);

    // Now we have the ratios. We need to determine the direction.
    // this is a function of the imbalance vector. We could determine
    // which side we are on, and then compute our position along that
    // to determine a point on the triangle, and then multiply by the imb_r
    // to obtain the actual point.
    // At least one value of imb will be zero.
    var first_zero = -1;
    var p0,p1,alpha;
    // the points are OPPOSITE the zero
    if (imb.x == 0) {
        first_zero = 0;
        // Which way should it be?
        p0 = WTC[2];
        p1 = WTC[1];
        alpha = imb.y/(imb.y + imb.z);
    } else if (imb.y == 0) {
        first_zero = 1;
        p0 = WTC[2];
        p1 = WTC[0];
        alpha = imb.z/(imb.x + imb.y);        
    } else if (imb.z == 0) {
        first_zero = 2;
        p0 = WTC[0];
        p1 = WTC[1];
        alpha = imb.x/(imb.x + imb.z);        
    }
    console.assert(first_zero != -1);
    var onTriangle = new THREE.Vector2();
    onTriangle.lerpVectors(p0,p1,alpha);
    // now onTriangle, should in theory be a point on the triangle
    console.log("ON TRIANGLE",onTriangle);
    // now, having found that we interpolate a ray to it of length bal_r...
    var pnt = new THREE.Vector2();
    var origin = new THREE.Vector2(0,0);
    // Why this choice?
    pnt.lerpVectors(origin,onTriangle,imb_r);
    return pnt;
}

function testTriBalance2to3() {
    let p = new THREE.Vector2(30000,30);    
    TriBalance2to3(p,WORLD_TRIANGLE_COORDS,L1NORM);
    let py = new THREE.Vector2(0,WORLD_TRIANGLE_COORDS[2][1]);
    TriBalance2to3(py,WORLD_TRIANGLE_COORDS,L1NORM);
}

function testInversion() {
    let p = new THREE.Vector2(30,30);    
    var vp = TriBalance2to3(p,WORLD_TRIANGLE_COORDS,L1NORM);
    var vp_inv = invertTriBalance2to3(vp,WORLD_TRIANGLE_COORDS,L1);
    // test length here
    var vpc = vp_inv.clone();
    vpc.sub(p);
    console.assert(vpc.length() < 1e-4);
    
    let py = new THREE.Vector2(0,WORLD_TRIANGLE_COORDS[2][1]);
    var vpy = TriBalance2to3(py,WORLD_TRIANGLE_COORDS,L1NORM);    
    var vpy_inv = invertTriBalance2to3(vpy,WORLD_TRIANGLE_COORDS,L1);
    
    var vpyc = vpy_inv.clone();
    vpyc.sub(py);
    console.assert(vpyc.length() < 1e-4);
}



/**
 * Setup a given element as a dropzone.
 *
 * @param {HTMLElement|String} el
 * @param {String} accept
 */
function setupDropzone (el, accept) {
  interact(el)
        .on('dropactivate', e => { console.log(e.type);
                                   // I copied this from interact.js, but it produces an error --- however it,
                                   // is absolutely requried!
                                   e.reject();
                                 })
    .dropzone({
      accept: accept,
      ondropactivate: function (event) {
        addClass(event.relatedTarget, '-drop-possible');
      },
      ondropdeactivate: function (event) {
        removeClass(event.relatedTarget, '-drop-possible');
      },
    })
    .on('dropactivate', function (event) {
      const active = event.target.getAttribute('active')|0;

      // change style if it was previously not active
      if (active === 0) {
        addClass(event.target, '-drop-possible');
        event.target.textContent = 'Drop me here!';
      }

      event.target.setAttribute('active', active + 1);
    })
    .on('dropdeactivate', function (event) {
      const active = event.target.getAttribute('active')|0;

      // change style if it was previously active
      // but will no longer be active
      if (active === 1) {
        removeClass(event.target, '-drop-possible');
        event.target.textContent = 'Dropzone';
      }

      event.target.setAttribute('active', active - 1);
    })
    .on('dragenter', function (event) {
        addClass(event.target, '-drop-over');
        event.relatedTarget.textContent = 'I\'m in';
        event.relatedTarget.style.width = "50px";
        event.relatedTarget.style.height = "30px";
        event.relatedTarget.style.fontSize = "xx-small";
    })
    .on('dragleave', function (event) {
      removeClass(event.target, '-drop-over');
      event.relatedTarget.textContent = 'Drag me…';
    })
    .on('drop', function (event) {
//        console.log("drop event",event);
      removeClass(event.target, '-drop-over');
        event.relatedTarget.textContent = 'Dropped';
        var element = event.relatedTarget;
        console.log("element",element.offsetLeft,element.offsetTop);
        console.log("this", event.target.offsetLeft,event.target.offsetTop);
        var draggedBox = element.getBoundingClientRect();
        element.textContent = CUR_TEXT;                
        var droppableBox = event.target.getBoundingClientRect();
        console.log("bounding",
                    event.target.getBoundingClientRect());
        console.log("bounding",
                    draggedBox);
        var xc = event.dragEvent.clientX;
        var yc = event.dragEvent.clientY;
//        console.log("xc,yc",xc,yc);
        var y = yc - droppableBox.y;
        var x = xc - droppableBox.x;
        // we need to convert this to "world" coordinates, not viewport...
        var yc = -(y + -250);
        var xc = x + -250;
        console.log("X,Y",xc,yc);
        var atp = {x: xc,y: yc};
        ADDED_TET_PROJs.push(atp);

        let bal = TriBalance2to3(atp,WORLD_TRIANGLE_COORDS,L1NORM);
        
        console.log("BALANCE",bal);

        $( "#mind" ).text( (bal.x * 100).toFixed(0) +  "%" );
        $( "#body" ).text( (bal.y * 100).toFixed(0) +  "%" );
        $( "#spirit" ).text( (bal.z * 100).toFixed(0) +  "%" );        
        
        render_svgs();
    });
}

function addClass (element, className) {
  if (element.classList) {
    return element.classList.add(className);
  }
  else {
    element.className += ' ' + className;
  }
}

function removeClass (element, className) {
  if (element.classList) {
    return element.classList.remove(className);
  }
  else {
    element.className = element.className.replace(new RegExp(className + ' *', 'g'), '');
  }
}

interact(document).on('ready', function () {
  transformProp = 'transform' in document.body.style
    ? 'transform': 'webkitTransform' in document.body.style
      ? 'webkitTransform': 'mozTransform' in document.body.style
        ? 'mozTransform': 'oTransform' in document.body.style
          ? 'oTransform': 'msTransform' in document.body.style
            ? 'msTransform': null;
});

WORLD_TRIANGLE_COORDS = get_world_triangle();

testGetRayToLineSegmentIntersection();
testTriBalance2to3();
testInversion();

      </script>

</body>
</html>
